name: Deploy SAM Multi-Lambda

on:
  push:
    branches: [ "main" ]
    paths:
      - "src/functions/**"
      - "scripts/generate_template.py"
      - ".github/workflows/deploy.yml"
  workflow_dispatch:
    inputs:
      drift_resolution:
        description: 'How to handle drift if detected'
        required: false
        default: 'prompt'
        type: choice
        options:
        - 'prompt'
        - 'accept_console'
        - 'overwrite_console'
        - 'abort'
      force_deploy:
        description: 'Force deployment bypassing all drift checks'
        required: false
        default: false
        type: boolean

permissions:
  id-token: write   # for OIDC
  contents: write   # for git operations when accepting console changes
  pull-requests: write   # for creating PRs if needed

env:
  AWS_REGION: us-east-1
  ARTIFACT_BUCKET: ayush-lambda-artifacts
  STACK_NAME: my-multi-lambda-stack-actions

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment:
      name: production   # set required reviewers on this environment for approvals

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch full git history for drift detection

      - name: Print OIDC token claims
        run: |
          echo "${ACTIONS_ID_TOKEN_REQUEST_TOKEN}" | cut -d '.' -f1 | base64 -d -i 2>/dev/null || true
          echo "${ACTIONS_ID_TOKEN_REQUEST_TOKEN}" | cut -d '.' -f2 | base64 -d -i 2>/dev/null || true 

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::975049970782:role/GithubActionsRole
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.13"

      - name: Install tooling
        run: |
          pip install --upgrade pip
          pip install aws-sam-cli pyyaml cfn-lint

      - name: Generate template.yaml
        run: python scripts/generate_template.py

      - name: Validate (SAM + cfn-lint)
        run: |
          sam validate --template template.yaml
          cfn-lint template.yaml

      - name: Initial Drift Check
        id: initial-drift
        run: |
          if aws cloudformation describe-stacks --stack-name ${{ env.STACK_NAME }} >/dev/null 2>&1; then
            echo "âœ… Stack exists, checking for drift..."
            
            # Start CloudFormation drift detection
            DRIFT_ID=$(aws cloudformation detect-stack-drift \
              --stack-name ${{ env.STACK_NAME }} \
              --query 'StackDriftDetectionId' --output text)
            
            echo "CloudFormation drift detection started with ID: $DRIFT_ID"
            
            # Poll for drift detection completion
            echo "â³ Waiting for CloudFormation drift detection to complete..."
            while true; do
              STATUS=$(aws cloudformation describe-stack-drift-detection-status \
                --stack-drift-detection-id $DRIFT_ID \
                --query 'DetectionStatus' --output text)
              
              if [ "$STATUS" = "DETECTION_COMPLETE" ]; then
                echo "âœ… CloudFormation drift detection completed"
                break
              elif [ "$STATUS" = "DETECTION_FAILED" ]; then
                echo "âŒ CloudFormation drift detection failed"
                exit 1
              else
                echo "â³ CloudFormation drift detection in progress (status: $STATUS)..."
                sleep 5
              fi
            done
            
            # Get CloudFormation drift status
            DRIFT_STATUS=$(aws cloudformation describe-stack-drift-detection-status \
              --stack-drift-detection-id $DRIFT_ID \
              --query 'StackDriftStatus' --output text)
            
            echo "CloudFormation drift status: $DRIFT_STATUS"
            
            if [ "$DRIFT_STATUS" = "DRIFTED" ]; then
              echo "âŒ CloudFormation stack has drifted! Manual changes detected."
              
              # Get detailed drift information
              echo "ðŸ“‹ CloudFormation Drift Details:"
              aws cloudformation describe-stack-resource-drifts \
                --stack-name ${{ env.STACK_NAME }} \
                --query 'StackResourceDrifts[?StackResourceDriftStatus==`MODIFIED`].[LogicalResourceId,ResourceType,StackResourceDriftStatus]' \
                --output table
              
              echo "Please fix the CloudFormation drift in AWS console before deploying."
              exit 1
            else
              echo "âœ… No CloudFormation drift detected"
            fi
            
            # Lambda-specific drift detection (CloudFormation can't detect Lambda code changes)
            echo "ðŸ” Checking Lambda function code drift..."
            echo "â„¹ï¸  Drift detection compares AWS deployed code with the last deployed commit"
            echo "â„¹ï¸  This detects manual changes made in AWS console, not legitimate repo updates"
            
            # Get the last deployed commit hash from stack tags
            LAST_DEPLOYED_COMMIT=$(aws cloudformation describe-stacks \
              --stack-name ${{ env.STACK_NAME }} \
              --query 'Stacks[0].Tags[?Key==`GitCommit`].Value' --output text 2>/dev/null || echo "")
            
            if [ -z "$LAST_DEPLOYED_COMMIT" ] || [ "$LAST_DEPLOYED_COMMIT" = "None" ]; then
              echo "âš ï¸  No previous deployment commit found in stack tags"
              echo "â„¹ï¸  This might be the first deployment or an old stack without commit tracking"
              echo "â„¹ï¸  Skipping Lambda drift detection for this deployment"
              echo "ðŸ’¡ Future deployments will include drift detection"
            else
              echo "ðŸ“‹ Last deployed commit: $LAST_DEPLOYED_COMMIT"
              echo "ðŸ“‹ Current commit: ${{ github.sha }}"
              
              if [ "$LAST_DEPLOYED_COMMIT" = "${{ github.sha }}" ]; then
                echo "â„¹ï¸  Same commit as last deployment - no drift check needed"
              else
                echo "â„¹ï¸  Different commit detected - this is a legitimate update, not drift"
                echo "ðŸ“‹ Checking for manual changes made since last deployment..."
                
                # Get all Lambda functions from the stack
                LAMBDA_FUNCTIONS=$(aws cloudformation describe-stack-resources \
                  --stack-name ${{ env.STACK_NAME }} \
                  --query 'StackResources[?ResourceType==`AWS::Lambda::Function`].PhysicalResourceId' \
                  --output text)
                
                if [ -n "$LAMBDA_FUNCTIONS" ]; then
                  LAMBDA_DRIFT_DETECTED=false
                  
                  for FUNCTION_NAME in $LAMBDA_FUNCTIONS; do
                    echo "ðŸ“‹ Checking function: $FUNCTION_NAME"
                    
                    # Find the function's logical ID from the template
                    LOGICAL_ID=$(aws cloudformation describe-stack-resources \
                      --stack-name ${{ env.STACK_NAME }} \
                      --query "StackResources[?PhysicalResourceId=='$FUNCTION_NAME'].LogicalResourceId" --output text)
                    
                    echo "  Function logical ID: $LOGICAL_ID"
                    
                    # Download current function code from AWS
                    echo "  Downloading current function code from AWS..."
                    TEMP_DIR_AWS="/tmp/${FUNCTION_NAME}-aws-code"
                    mkdir -p "$TEMP_DIR_AWS"
                    
                    # Get the function code URL and download it
                    DOWNLOAD_URL=$(aws lambda get-function \
                      --function-name $FUNCTION_NAME \
                      --query 'Code.Location' --output text)
                    
                    if [ "$DOWNLOAD_URL" != "None" ] && [ -n "$DOWNLOAD_URL" ]; then
                      # Download and extract the current AWS code
                      curl -s "$DOWNLOAD_URL" -o "$TEMP_DIR_AWS/current-code.zip"
                      cd "$TEMP_DIR_AWS"
                      unzip -q current-code.zip
                      rm current-code.zip
                      cd - >/dev/null
                      
                      # Get the code from the last deployed commit for comparison
                      echo "  Getting code from last deployed commit: $LAST_DEPLOYED_COMMIT"
                      TEMP_DIR_LAST="/tmp/${FUNCTION_NAME}-last-commit"
                      mkdir -p "$TEMP_DIR_LAST"
                      
                      # Find the source function directory using dynamic mapping
                      SOURCE_FUNCTION_DIR=""
                      # Convert logical ID to lowercase for case-insensitive matching
                      LOGICAL_ID_LOWER=$(echo "$LOGICAL_ID" | tr '[:upper:]' '[:lower:]')
                      
                      echo "  Attempting to map logical ID '$LOGICAL_ID' to source directory..."
                      
                      # Dynamic mapping strategy with multiple approaches
                      for func_dir in src/functions/*/; do
                        if [ -d "$func_dir" ]; then
                          func_name=$(basename "$func_dir")
                          func_name_lower=$(echo "$func_name" | tr '[:upper:]' '[:lower:]')
                          
                          echo "    Checking directory: $func_name"
                          
                          # Strategy 1: Exact match (case-insensitive)
                          if [ "$LOGICAL_ID_LOWER" = "$func_name_lower" ]; then
                            echo "    âœ… Exact match found: $func_name"
                            SOURCE_FUNCTION_DIR="$func_dir"
                            break
                          fi
                          
                          # Strategy 2: Logical ID contains directory name
                          if [[ "$LOGICAL_ID_LOWER" == *"$func_name_lower"* ]]; then
                            echo "    âœ… Substring match found: $func_name (in $LOGICAL_ID)"
                            SOURCE_FUNCTION_DIR="$func_dir"
                            break
                          fi
                          
                          # Strategy 3: Directory name contains logical ID
                          if [[ "$func_name_lower" == *"$LOGICAL_ID_LOWER"* ]]; then
                            echo "    âœ… Reverse substring match found: $LOGICAL_ID (in $func_name)"
                            SOURCE_FUNCTION_DIR="$func_dir"
                            break
                          fi
                          
                          # Strategy 4: Handle kebab-case to camelCase conversion
                          # Convert kebab-case to camelcase for comparison
                          func_name_camel=$(echo "$func_name" | sed 's/-\([a-z]\)/\U\1/g')
                          func_name_camel_lower=$(echo "$func_name_camel" | tr '[:upper:]' '[:lower:]')
                          
                          if [[ "$LOGICAL_ID_LOWER" == *"$func_name_camel_lower"* ]]; then
                            echo "    âœ… Kebab-to-camel match found: $func_name -> $func_name_camel"
                            SOURCE_FUNCTION_DIR="$func_dir"
                            break
                          fi
                        fi
                      done
                      
                      # Check if mapping was successful
                      if [ -n "$SOURCE_FUNCTION_DIR" ] && [ -d "$SOURCE_FUNCTION_DIR" ]; then
                        echo "  Mapped to source directory: $SOURCE_FUNCTION_DIR"
                        
                        # Get the file from the last deployed commit
                        MAIN_FILE=""
                        if [ -f "$SOURCE_FUNCTION_DIR/lambda_function.py" ]; then
                          MAIN_FILE="lambda_function.py"
                        elif [ -f "$SOURCE_FUNCTION_DIR/app.py" ]; then
                          MAIN_FILE="app.py"
                        elif [ -f "$SOURCE_FUNCTION_DIR/index.js" ]; then
                          MAIN_FILE="index.js"
                        fi
                        
                        if [ -n "$MAIN_FILE" ]; then
                          echo "  Comparing main file: $MAIN_FILE"
                          
                          # Get the file content from the last deployed commit
                          # Remove trailing slash from SOURCE_FUNCTION_DIR for proper git path
                          SOURCE_PATH="${SOURCE_FUNCTION_DIR%/}/$MAIN_FILE"
                          echo "  Retrieving file from git: $LAST_DEPLOYED_COMMIT:$SOURCE_PATH"
                          
                          # Verify the commit exists first
                          if ! git cat-file -e "$LAST_DEPLOYED_COMMIT" 2>/dev/null; then
                            echo "  âš ï¸  Commit $LAST_DEPLOYED_COMMIT not found in git history"
                            echo "  â„¹ï¸  Skipping drift check for this function"
                            rm -rf "$TEMP_DIR_AWS" "$TEMP_DIR_LAST"
                            continue
                          fi
                          
                          # Get the file content from the last deployed commit
                          if ! git show "$LAST_DEPLOYED_COMMIT:$SOURCE_PATH" > "$TEMP_DIR_LAST/$MAIN_FILE" 2>/dev/null; then
                            echo "  âš ï¸  Could not retrieve file $SOURCE_PATH from commit $LAST_DEPLOYED_COMMIT"
                            echo "  â„¹ï¸  File may not have existed in that commit"
                            echo "  â„¹ï¸  Skipping drift check for this function"
                            rm -rf "$TEMP_DIR_AWS" "$TEMP_DIR_LAST"
                            continue
                          fi
                          
                          # Calculate checksums - compare AWS deployed code with last deployed commit
                          LAST_COMMIT_CHECKSUM=$(sha256sum "$TEMP_DIR_LAST/$MAIN_FILE" | cut -d' ' -f1)
                          AWS_CHECKSUM=$(sha256sum "$TEMP_DIR_AWS/$MAIN_FILE" 2>/dev/null | cut -d' ' -f1 || echo "missing")
                          
                          echo "  Last deployed commit checksum: $LAST_COMMIT_CHECKSUM"
                          echo "  AWS deployed checksum: $AWS_CHECKSUM"
                          
                          if [ "$LAST_COMMIT_CHECKSUM" != "$AWS_CHECKSUM" ]; then
                            echo "  âŒ Lambda function $FUNCTION_NAME has code drift!"
                            echo "  ðŸ“‹ AWS deployed code differs from last deployed commit"
                            echo "  ðŸ”§ Someone manually modified the function code in AWS console"
                            
                            # Show the differences if possible
                            if [ "$AWS_CHECKSUM" != "missing" ]; then
                              echo "  ðŸ“‹ Code differences detected:"
                              diff -u "$TEMP_DIR_LAST/$MAIN_FILE" "$TEMP_DIR_AWS/$MAIN_FILE" || true
                            else
                              echo "  ðŸ“‹ Main file missing in AWS deployment"
                            fi
                            
                            LAMBDA_DRIFT_DETECTED=true
                          else
                            echo "  âœ… Lambda function $FUNCTION_NAME matches last deployed commit"
                          fi
                        else
                          echo "  âš ï¸  Could not find main Lambda file in source directory"
                          echo "  â„¹ï¸  Skipping drift check for this function"
                        fi
                      else
                        echo "  âš ï¸  Could not map function to source directory"
                        echo "  â„¹ï¸  Available directories: $(ls -d src/functions/*/ 2>/dev/null | tr '\n' ' ')"
                        echo "  â„¹ï¸  Skipping drift check for this function"
                      fi
                      
                      # Clean up temporary directories
                      rm -rf "$TEMP_DIR_AWS" "$TEMP_DIR_LAST"
                    else
                      echo "  âš ï¸  Could not get download URL for function code"
                      echo "  â„¹ï¸  Skipping drift check for this function"
                    fi
                  done
                  
                  if [ "$LAMBDA_DRIFT_DETECTED" = true ]; then
                    echo ""
                    echo "âŒ Lambda code drift detected!"
                    echo "ðŸ”§ Someone manually modified Lambda function code in the AWS console"
                    echo "ðŸ’¡ This type of drift cannot be detected by CloudFormation drift detection"
                    echo ""
                    echo "drift_detected=true" >> $GITHUB_OUTPUT
                    echo "drift_summary=Lambda code drift detected - manual console changes found" >> $GITHUB_OUTPUT
                  else
                    echo "âœ… No Lambda code drift detected"
                    echo "drift_detected=false" >> $GITHUB_OUTPUT
                  fi
                else
                  echo "â„¹ï¸  No Lambda functions found in stack"
                  echo "drift_detected=false" >> $GITHUB_OUTPUT
                fi
              fi
            fi
            
            # Ensure drift_detected is set for cases where no Lambda drift check was performed
            if ! grep -q "drift_detected=" $GITHUB_OUTPUT 2>/dev/null; then
              echo "drift_detected=false" >> $GITHUB_OUTPUT
            fi
            
            echo "âœ… All drift checks passed, proceeding with deployment"
            echo "stack_exists=true" >> $GITHUB_OUTPUT
          else
            echo "ðŸ“¦ Stack doesn't exist yet - this will be a first deployment"
            echo "âœ… Will create stack and then check for drift"
            echo "stack_exists=false" >> $GITHUB_OUTPUT
            echo "drift_detected=false" >> $GITHUB_OUTPUT
          fi

      - name: Build (use Lambda-like container for deps)
        run: sam build --use-container

      - name: Package
        run: |
          sam package \
               --template-file .aws-sam/build/template.yaml \
               --s3-bucket ${{ env.ARTIFACT_BUCKET }} \
               --output-template-file packaged.yaml

      - name: Create Stack Infrastructure (First Deployment)
        if: steps.initial-drift.outputs.stack_exists == 'false'
        run: |
          echo "ðŸš€ Creating new stack infrastructure..."
          
          # Create changeset without executing it
          sam deploy \
               --template-file packaged.yaml \
               --stack-name ${{ env.STACK_NAME }} \
               --capabilities CAPABILITY_IAM CAPABILITY_AUTO_EXPAND \
               --no-execute-changeset
          
          # Execute the changeset to create stack
          CHANGESET_NAME=$(aws cloudformation list-change-sets \
            --stack-name ${{ env.STACK_NAME }} \
            --query 'Summaries[0].ChangeSetName' --output text)
          
          echo "Executing changeset: $CHANGESET_NAME"
          aws cloudformation execute-change-set \
            --change-set-name $CHANGESET_NAME \
            --stack-name ${{ env.STACK_NAME }}
          
          # Wait for stack creation to complete
          echo "â³ Waiting for stack creation to complete..."
          aws cloudformation wait stack-create-complete \
            --stack-name ${{ env.STACK_NAME }}
          
          echo "âœ… Stack infrastructure created successfully"

      - name: Post-Creation Drift Check (New Stacks Only)
        if: steps.initial-drift.outputs.stack_exists == 'false'
        run: |
          echo "ðŸ” Running drift check after stack creation (before deployment)..."
          
          # Wait a moment for stack to stabilize
          sleep 10
          
          # Start drift detection
          DRIFT_ID=$(aws cloudformation detect-stack-drift \
            --stack-name ${{ env.STACK_NAME }} \
            --query 'StackDriftDetectionId' --output text)
          
          echo "Drift detection started with ID: $DRIFT_ID"
          
          # Poll for drift detection completion
          echo "â³ Waiting for drift detection to complete..."
          while true; do
            STATUS=$(aws cloudformation describe-stack-drift-detection-status \
              --stack-drift-detection-id $DRIFT_ID \
              --query 'DetectionStatus' --output text)
            
            if [ "$STATUS" = "DETECTION_COMPLETE" ]; then
              echo "âœ… Drift detection completed"
              break
            elif [ "$STATUS" = "DETECTION_FAILED" ]; then
              echo "âŒ Drift detection failed"
              exit 1
            else
              echo "â³ Drift detection in progress (status: $STATUS)..."
              sleep 5
            fi
          done
          
          # Get drift status
          DRIFT_STATUS=$(aws cloudformation describe-stack-drift-detection-status \
            --stack-drift-detection-id $DRIFT_ID \
            --query 'StackDriftStatus' --output text)
          
          echo "Post-creation drift status: $DRIFT_STATUS"
          
          if [ "$DRIFT_STATUS" = "DRIFTED" ]; then
            echo "âŒ Stack has drifted after creation! Manual changes detected."
            
            # Get detailed drift information
            echo "ðŸ“‹ Drift Details:"
            aws cloudformation describe-stack-resource-drifts \
              --stack-name ${{ env.STACK_NAME }} \
              --query 'StackResourceDrifts[?StackResourceDriftStatus==`MODIFIED`].[LogicalResourceId,ResourceType,StackResourceDriftStatus]' \
              --output table
            
            echo "âš ï¸  Someone made manual changes to the stack after creation!"
            echo "âŒ Deployment blocked - fix drift before proceeding"
            exit 1
          else
            echo "âœ… No drift detected after stack creation"
            echo "âœ… Proceeding with code deployment..."
          fi

      - name: Handle Drift Detection
        if: steps.initial-drift.outputs.drift_detected == 'true' && github.event.inputs.force_deploy != 'true' && github.event.inputs.drift_resolution != 'accept_console' && github.event.inputs.drift_resolution != 'overwrite_console' && github.event.inputs.drift_resolution != 'abort'
        run: |
          echo "ðŸš¨ DRIFT DETECTED - MANUAL APPROVAL REQUIRED"
          echo ""
          echo "ðŸ“‹ Drift Summary: ${{ steps.initial-drift.outputs.drift_summary }}"
          echo ""
          echo "ðŸ”§ Resolution Options:"
          echo "  1. Accept Console Changes - Pull console changes into repository"
          echo "  2. Overwrite Console Changes - Deploy repository code (discards console changes)"
          echo "  3. Abort - Stop deployment for manual investigation"
          echo ""
          echo "âš ï¸  Current Resolution Setting: ${{ github.event.inputs.drift_resolution || 'prompt (default)' }}"
          echo "âš ï¸  Trigger Type: ${{ github.event_name }}"
          echo ""
          echo "ðŸ›‘ Workflow paused for manual approval"
          echo "ðŸ‘¤ Please review the drift details above and re-run this workflow with your chosen resolution:"
          echo "   - drift_resolution: accept_console (to accept console changes)"
          echo "   - drift_resolution: overwrite_console (to overwrite with repo code)"
          echo "   - drift_resolution: abort (to stop deployment)"
          echo ""
          echo "ðŸ’¡ You can also set force_deploy: true to bypass all drift checks"
          exit 1

      - name: Accept Console Changes
        if: steps.initial-drift.outputs.drift_detected == 'true' && github.event.inputs.drift_resolution == 'accept_console'
        run: |
          echo "âœ… Accepting console changes and syncing with repository..."
          echo ""
          echo "ðŸ”„ This will:"
          echo "  1. Download current AWS Lambda code"
          echo "  2. Update repository files with console changes"
          echo "  3. Create a commit with the console changes"
          echo "  4. Continue with deployment using the updated code"
          echo ""
          
          # Get all Lambda functions from the stack
          LAMBDA_FUNCTIONS=$(aws cloudformation describe-stack-resources \
            --stack-name ${{ env.STACK_NAME }} \
            --query 'StackResources[?ResourceType==`AWS::Lambda::Function`].PhysicalResourceId' \
            --output text)
          
          if [ -n "$LAMBDA_FUNCTIONS" ]; then
            for FUNCTION_NAME in $LAMBDA_FUNCTIONS; do
              echo "ðŸ“¥ Processing function: $FUNCTION_NAME"
              
              # Find the function's logical ID and map to source directory
              LOGICAL_ID=$(aws cloudformation describe-stack-resources \
                --stack-name ${{ env.STACK_NAME }} \
                --query "StackResources[?PhysicalResourceId=='$FUNCTION_NAME'].LogicalResourceId" --output text)
              
              # Download current function code
              TEMP_DIR="/tmp/${FUNCTION_NAME}-console-code"
              mkdir -p "$TEMP_DIR"
              
              DOWNLOAD_URL=$(aws lambda get-function \
                --function-name $FUNCTION_NAME \
                --query 'Code.Location' --output text)
              
              if [ "$DOWNLOAD_URL" != "None" ] && [ -n "$DOWNLOAD_URL" ]; then
                curl -s "$DOWNLOAD_URL" -o "$TEMP_DIR/console-code.zip"
                cd "$TEMP_DIR"
                unzip -q console-code.zip
                rm console-code.zip
                cd - >/dev/null
                
                # Map to source directory using enhanced logic (same as overwrite_console)
                SOURCE_FUNCTION_DIR=""
                LOGICAL_ID_LOWER=$(echo "$LOGICAL_ID" | tr '[:upper:]' '[:lower:]')
                
                echo "  ðŸ” Mapping function '$FUNCTION_NAME' (logical: '$LOGICAL_ID') to source directory..."
                echo "  ðŸ“‹ Available directories: $(ls -d src/functions/*/ 2>/dev/null | xargs -n1 basename | tr '\n' ' ')"
                
                for func_dir in src/functions/*/; do
                  if [ -d "$func_dir" ]; then
                    func_name=$(basename "$func_dir")
                    func_name_lower=$(echo "$func_name" | tr '[:upper:]' '[:lower:]')
                    
                    echo "    ðŸ” Checking directory: $func_name"
                    
                    # Strategy 1: Exact match (case-insensitive)
                    if [ "$LOGICAL_ID_LOWER" = "$func_name_lower" ]; then
                      echo "    âœ… Exact match found: $func_name"
                      SOURCE_FUNCTION_DIR="$func_dir"
                      break
                    fi
                    
                    # Strategy 2: Function name matches directory name
                    FUNCTION_NAME_LOWER=$(echo "$FUNCTION_NAME" | tr '[:upper:]' '[:lower:]')
                    if [ "$FUNCTION_NAME_LOWER" = "$func_name_lower" ]; then
                      echo "    âœ… Function name match found: $func_name"
                      SOURCE_FUNCTION_DIR="$func_dir"
                      break
                    fi
                    
                    # Strategy 3: Logical ID contains directory name
                    if [[ "$LOGICAL_ID_LOWER" == *"$func_name_lower"* ]]; then
                      echo "    âœ… Substring match found: $func_name (in $LOGICAL_ID)"
                      SOURCE_FUNCTION_DIR="$func_dir"
                      break
                    fi
                    
                    # Strategy 4: Directory name contains logical ID
                    if [[ "$func_name_lower" == *"$LOGICAL_ID_LOWER"* ]]; then
                      echo "    âœ… Reverse substring match found: $LOGICAL_ID (in $func_name)"
                      SOURCE_FUNCTION_DIR="$func_dir"
                      break
                    fi
                    
                    # Strategy 5: Function name contains directory name
                    if [[ "$FUNCTION_NAME_LOWER" == *"$func_name_lower"* ]]; then
                      echo "    âœ… Function name contains directory: $func_name (in $FUNCTION_NAME)"
                      SOURCE_FUNCTION_DIR="$func_dir"
                      break
                    fi
                    
                    # Strategy 6: Directory name contains function name
                    if [[ "$func_name_lower" == *"$FUNCTION_NAME_LOWER"* ]]; then
                      echo "    âœ… Directory contains function name: $FUNCTION_NAME (in $func_name)"
                      SOURCE_FUNCTION_DIR="$func_dir"
                      break
                    fi
                    
                    # Strategy 7: Handle kebab-case to camelCase conversion
                    func_name_camel=$(echo "$func_name" | sed 's/-\([a-z]\)/\U\1/g')
                    func_name_camel_lower=$(echo "$func_name_camel" | tr '[:upper:]' '[:lower:]')
                    
                    if [[ "$LOGICAL_ID_LOWER" == *"$func_name_camel_lower"* ]]; then
                      echo "    âœ… Kebab-to-camel match found: $func_name -> $func_name_camel"
                      SOURCE_FUNCTION_DIR="$func_dir"
                      break
                    fi
                    
                    # Strategy 8: Handle camelCase to kebab-case conversion
                    logical_id_kebab=$(echo "$LOGICAL_ID" | sed 's/\([A-Z]\)/-\L\1/g' | sed 's/^-//')
                    logical_id_kebab_lower=$(echo "$logical_id_kebab" | tr '[:upper:]' '[:lower:]')
                    
                    if [ "$logical_id_kebab_lower" = "$func_name_lower" ]; then
                      echo "    âœ… CamelCase-to-kebab match found: $LOGICAL_ID -> $logical_id_kebab"
                      SOURCE_FUNCTION_DIR="$func_dir"
                      break
                    fi
                  fi
                done
                
                if [ -n "$SOURCE_FUNCTION_DIR" ] && [ -d "$SOURCE_FUNCTION_DIR" ]; then
                  echo "  ðŸ“ Updating source directory: $SOURCE_FUNCTION_DIR"
                  
                  # List what's in the temp directory
                  echo "  ðŸ“‹ Files downloaded from console:"
                  ls -la "$TEMP_DIR/" || echo "  âš ï¸  Could not list temp directory contents"
                  
                  # List what's in the source directory
                  echo "  ðŸ“‹ Files in source directory:"
                  ls -la "$SOURCE_FUNCTION_DIR/" || echo "  âš ï¸  Could not list source directory contents"
                  
                  # Find main file and update it
                  MAIN_FILE=""
                  if [ -f "$SOURCE_FUNCTION_DIR/lambda_function.py" ]; then
                    MAIN_FILE="lambda_function.py"
                    echo "  ðŸ“ Found lambda_function.py in source directory"
                  elif [ -f "$SOURCE_FUNCTION_DIR/app.py" ]; then
                    MAIN_FILE="app.py"
                    echo "  ðŸ“ Found app.py in source directory"
                  elif [ -f "$SOURCE_FUNCTION_DIR/index.js" ]; then
                    MAIN_FILE="index.js"
                    echo "  ðŸ“ Found index.js in source directory"
                  else
                    echo "  âš ï¸  No main file found in source directory"
                  fi
                  
                  if [ -n "$MAIN_FILE" ]; then
                    if [ -f "$TEMP_DIR/$MAIN_FILE" ]; then
                      echo "  ðŸ“ Console has $MAIN_FILE - comparing with repository version"
                      
                      # Show file sizes for comparison
                      REPO_SIZE=$(stat -c%s "$SOURCE_FUNCTION_DIR/$MAIN_FILE" 2>/dev/null || echo "0")
                      CONSOLE_SIZE=$(stat -c%s "$TEMP_DIR/$MAIN_FILE" 2>/dev/null || echo "0")
                      echo "  ðŸ“Š Repository file size: $REPO_SIZE bytes"
                      echo "  ðŸ“Š Console file size: $CONSOLE_SIZE bytes"
                      
                      # Show checksums for comparison
                      REPO_CHECKSUM=$(sha256sum "$SOURCE_FUNCTION_DIR/$MAIN_FILE" 2>/dev/null | cut -d' ' -f1 || echo "missing")
                      CONSOLE_CHECKSUM=$(sha256sum "$TEMP_DIR/$MAIN_FILE" 2>/dev/null | cut -d' ' -f1 || echo "missing")
                      echo "  ðŸ” Repository checksum: $REPO_CHECKSUM"
                      echo "  ðŸ” Console checksum: $CONSOLE_CHECKSUM"
                      
                      if [ "$REPO_CHECKSUM" != "$CONSOLE_CHECKSUM" ]; then
                        echo "  âœ… Files are different - updating repository with console changes"
                        cp "$TEMP_DIR/$MAIN_FILE" "$SOURCE_FUNCTION_DIR/$MAIN_FILE"
                        echo "  ðŸ“ Updated $MAIN_FILE with console changes"
                        
                        # Verify the copy worked
                        NEW_CHECKSUM=$(sha256sum "$SOURCE_FUNCTION_DIR/$MAIN_FILE" 2>/dev/null | cut -d' ' -f1 || echo "missing")
                        echo "  âœ… New repository checksum: $NEW_CHECKSUM"
                        
                        if [ "$NEW_CHECKSUM" = "$CONSOLE_CHECKSUM" ]; then
                          echo "  âœ… File successfully updated with console changes"
                        else
                          echo "  âŒ File copy failed - checksums don't match"
                        fi
                      else
                        echo "  â„¹ï¸  Files are identical - no changes needed"
                      fi
                    else
                      echo "  âš ï¸  Console download doesn't contain $MAIN_FILE"
                      echo "  ðŸ“‹ Console files available: $(ls "$TEMP_DIR/" 2>/dev/null | tr '\n' ' ')"
                    fi
                  fi
                else
                  echo "  âŒ Could not map function to source directory"
                fi
                
                rm -rf "$TEMP_DIR"
              fi
            done
            
            # Configure git for the commit
            echo ""
            echo "ðŸ”§ Configuring git for commit..."
            git config user.name "GitHub Actions"
            git config user.email "actions@github.com"
            
            echo "ðŸ“‹ Git configuration:"
            echo "  User: $(git config user.name)"
            echo "  Email: $(git config user.email)"
            
            # Check current git status
            echo ""
            echo "ðŸ“‹ Current git status:"
            git status
            
            echo ""
            echo "ðŸ“‹ Files in src/functions/ directory:"
            find src/functions/ -type f -name "*.py" -o -name "*.js" | head -20
            
            # Add and commit the changes
            echo ""
            echo "ðŸ”§ Adding changes to git..."
            git add src/functions/
            
            echo "ðŸ“‹ Git status after adding files:"
            git status
            
            echo ""
            echo "ðŸ“‹ Staged changes:"
            git diff --staged --name-only || echo "No staged changes found"
            
            echo ""
            echo "ðŸ“‹ Detailed staged changes:"
            git diff --staged || echo "No staged changes to show"
            
            if git diff --staged --quiet; then
              echo ""
              echo "â„¹ï¸  No changes to commit - files are identical"
              echo "ðŸ“‹ This means the console changes match the repository files"
            else
              echo ""
              echo "âœ… Changes detected - creating commit..."
              git commit -m "Accept console changes from AWS Lambda functions

              This commit incorporates manual changes that were made directly in the AWS console.
              
              Workflow: ${{ github.workflow }}
              Run ID: ${{ github.run_id }}
              Original commit: ${{ github.sha }}"
              
              echo "âœ… Console changes committed to repository"
              
              echo ""
              echo "ðŸ“‹ Latest commit:"
              git log -1 --oneline
              
              echo ""
              echo "ðŸš€ Pushing changes to remote repository..."
              git push origin main
              
              echo "âœ… Changes pushed to remote repository"
              
              # Update the commit SHA for deployment tagging
              NEW_COMMIT_SHA=$(git rev-parse HEAD)
              echo "ðŸ“‹ New commit SHA: $NEW_COMMIT_SHA"
              echo "ðŸ“‹ Original commit SHA: ${{ github.sha }}"
              
              # Export the new commit SHA for use in deployment step
              echo "DEPLOYMENT_COMMIT_SHA=$NEW_COMMIT_SHA" >> $GITHUB_ENV
              echo "âœ… Updated deployment commit SHA for stack tagging"
              
              # Set flag to rebuild since we updated source code
              echo "NEED_REBUILD=true" >> $GITHUB_ENV
              echo "âœ… Marked for rebuild due to console changes acceptance"
            fi
          fi

      - name: Overwrite Console Changes
        if: steps.initial-drift.outputs.drift_detected == 'true' && github.event.inputs.drift_resolution == 'overwrite_console'
        run: |
          echo "ðŸ”„ Overwriting console changes with repository code..."
          echo ""
          echo "ðŸ“‹ Drift Summary: ${{ steps.initial-drift.outputs.drift_summary }}"
          echo ""
          echo "âš ï¸  This will:"
          echo "  1. Deploy repository code to AWS Lambda functions"
          echo "  2. Overwrite any manual changes made in AWS console"
          echo "  3. Update commit tag to establish new baseline"
          echo "  4. Console changes will be permanently lost"
          echo ""
          echo "âœ… Proceeding with deployment - console changes will be overwritten"
          echo "ðŸ“‹ Repository code will be deployed as the authoritative source"
          echo ""
          echo "ðŸ”§ Debug Info:"
          echo "  - drift_detected: ${{ steps.initial-drift.outputs.drift_detected }}"
          echo "  - drift_resolution: ${{ github.event.inputs.drift_resolution }}"
          echo "  - force_deploy: ${{ github.event.inputs.force_deploy }}"
          echo "  - Next step (Deploy Code) should run with overwrite_console logic"

      - name: Abort on Drift
        if: steps.initial-drift.outputs.drift_detected == 'true' && github.event.inputs.drift_resolution == 'abort'
        run: |
          echo "ðŸ›‘ Deployment aborted due to drift detection"
          echo ""
          echo "ðŸ“‹ Drift Summary: ${{ steps.initial-drift.outputs.drift_summary }}"
          echo ""
          echo "ðŸ”§ Manual Action Required:"
          echo "  1. Review the drift details in the logs above"
          echo "  2. Decide whether to accept console changes or revert them"
          echo "  3. Re-run the workflow with appropriate drift_resolution setting"
          echo ""
          echo "ðŸ’¡ Resolution options:"
          echo "  - accept_console: Accept and commit console changes"
          echo "  - overwrite_console: Deploy repository code (discards console changes)"
          echo "  - force_deploy: Bypass all drift checks"
          exit 1

      - name: Rebuild After Console Changes
        if: env.NEED_REBUILD == 'true'
        run: |
          echo "ðŸ”„ Rebuilding and repackaging after accepting console changes..."
          echo ""
          echo "ðŸ“‹ Source code was updated with console changes"
          echo "ðŸ“‹ Need to rebuild to include the updated code in deployment"
          echo ""
          
          echo "ðŸ”§ Regenerating template.yaml with updated source code..."
          python scripts/generate_template.py
          
          echo "ðŸ”§ Rebuilding with updated source code..."
          sam build --use-container
          
          echo "ðŸ”§ Repackaging with updated build..."
          sam package \
               --template-file .aws-sam/build/template.yaml \
               --s3-bucket ${{ env.ARTIFACT_BUCKET }} \
               --output-template-file packaged.yaml
          
          echo "âœ… Rebuild completed - deployment package now contains console changes"

      - name: Deploy Code (Final Step)
        if: github.event.inputs.force_deploy == 'true' || steps.initial-drift.outputs.drift_detected != 'true' || (steps.initial-drift.outputs.drift_detected == 'true' && (github.event.inputs.drift_resolution == 'accept_console' || github.event.inputs.drift_resolution == 'overwrite_console'))
        run: |
          echo "ðŸ”§ Deploy Code Step - Debug Info:"
          echo "  - force_deploy: ${{ github.event.inputs.force_deploy }}"
          echo "  - drift_detected: ${{ steps.initial-drift.outputs.drift_detected }}"
          echo "  - drift_resolution: ${{ github.event.inputs.drift_resolution }}"
          echo "  - stack_exists: ${{ steps.initial-drift.outputs.stack_exists }}"
          echo ""
          
          if [ "${{ github.event.inputs.force_deploy }}" == "true" ]; then
            echo "ðŸš€ Force deployment - bypassing all drift checks"
          elif [ "${{ steps.initial-drift.outputs.drift_detected }}" == "true" ]; then
            if [ "${{ github.event.inputs.drift_resolution }}" == "accept_console" ]; then
              echo "âœ… Deploying with accepted console changes"
            elif [ "${{ github.event.inputs.drift_resolution }}" == "overwrite_console" ]; then
              echo "ðŸ”„ Deploying repository code - overwriting console changes"
              echo "âš ï¸  This deployment will replace AWS Lambda code with repository code"
              echo "âš ï¸  Any manual console changes will be permanently lost"
            fi
          elif [ "${{ steps.initial-drift.outputs.stack_exists }}" == "true" ]; then
            echo "ðŸ”„ Updating existing stack with new code..."
          else
            echo "ðŸ“¦ Deploying code to newly created stack..."
          fi
          
          echo ""
          echo "ðŸš€ Starting SAM deployment..."
          echo "ðŸ“‹ Template: packaged.yaml"
          echo "ðŸ“‹ Stack: ${{ env.STACK_NAME }}"
          echo ""
          
          if [ "${{ github.event.inputs.drift_resolution }}" == "overwrite_console" ]; then
            echo "ðŸ”„ Force updating Lambda functions to overwrite console changes..."
            
            # For overwrite_console, we need to force update the Lambda functions
            # First deploy the stack to ensure infrastructure is up to date
            # Determine which commit SHA to use for tagging
            COMMIT_FOR_TAGGING="${{ env.DEPLOYMENT_COMMIT_SHA || github.sha }}"
            echo "ðŸ“‹ Using commit for stack tagging: $COMMIT_FOR_TAGGING"
            
            sam deploy \
                 --template-file packaged.yaml \
                 --stack-name ${{ env.STACK_NAME }} \
                 --capabilities CAPABILITY_IAM CAPABILITY_AUTO_EXPAND \
                 --no-fail-on-empty-changeset \
                 --tags GitCommit="$COMMIT_FOR_TAGGING" \
                        GitBranch=${{ github.ref_name }} \
                        GitRepository=${{ github.repository }} \
                        DeploymentTime=$(date -u +"%Y-%m-%dT%H:%M:%SZ") \
                        WorkflowRun=${{ github.run_id }}
            
            echo ""
            echo "ðŸ”„ Force updating Lambda function code to overwrite console changes..."
            
            # Get all Lambda functions from the stack and force update their code
            LAMBDA_FUNCTIONS=$(aws cloudformation describe-stack-resources \
              --stack-name ${{ env.STACK_NAME }} \
              --query 'StackResources[?ResourceType==`AWS::Lambda::Function`].PhysicalResourceId' \
              --output text)
            
            if [ -n "$LAMBDA_FUNCTIONS" ]; then
              for FUNCTION_NAME in $LAMBDA_FUNCTIONS; do
                echo "ðŸ”„ Force updating function: $FUNCTION_NAME"
                
                # Find the function's logical ID and map to source directory
                LOGICAL_ID=$(aws cloudformation describe-stack-resources \
                  --stack-name ${{ env.STACK_NAME }} \
                  --query "StackResources[?PhysicalResourceId=='$FUNCTION_NAME'].LogicalResourceId" --output text)
                
                # Map to source directory using enhanced logic
                SOURCE_FUNCTION_DIR=""
                LOGICAL_ID_LOWER=$(echo "$LOGICAL_ID" | tr '[:upper:]' '[:lower:]')
                
                echo "  ðŸ” Mapping function '$FUNCTION_NAME' (logical: '$LOGICAL_ID') to source directory..."
                echo "  ðŸ“‹ Available directories: $(ls -d src/functions/*/ 2>/dev/null | xargs -n1 basename | tr '\n' ' ')"
                
                for func_dir in src/functions/*/; do
                  if [ -d "$func_dir" ]; then
                    func_name=$(basename "$func_dir")
                    func_name_lower=$(echo "$func_name" | tr '[:upper:]' '[:lower:]')
                    
                    echo "    ðŸ” Checking directory: $func_name"
                    
                    # Strategy 1: Exact match (case-insensitive)
                    if [ "$LOGICAL_ID_LOWER" = "$func_name_lower" ]; then
                      echo "    âœ… Exact match found: $func_name"
                      SOURCE_FUNCTION_DIR="$func_dir"
                      break
                    fi
                    
                    # Strategy 2: Function name matches directory name
                    FUNCTION_NAME_LOWER=$(echo "$FUNCTION_NAME" | tr '[:upper:]' '[:lower:]')
                    if [ "$FUNCTION_NAME_LOWER" = "$func_name_lower" ]; then
                      echo "    âœ… Function name match found: $func_name"
                      SOURCE_FUNCTION_DIR="$func_dir"
                      break
                    fi
                    
                    # Strategy 3: Logical ID contains directory name
                    if [[ "$LOGICAL_ID_LOWER" == *"$func_name_lower"* ]]; then
                      echo "    âœ… Substring match found: $func_name (in $LOGICAL_ID)"
                      SOURCE_FUNCTION_DIR="$func_dir"
                      break
                    fi
                    
                    # Strategy 4: Directory name contains logical ID
                    if [[ "$func_name_lower" == *"$LOGICAL_ID_LOWER"* ]]; then
                      echo "    âœ… Reverse substring match found: $LOGICAL_ID (in $func_name)"
                      SOURCE_FUNCTION_DIR="$func_dir"
                      break
                    fi
                    
                    # Strategy 5: Function name contains directory name
                    if [[ "$FUNCTION_NAME_LOWER" == *"$func_name_lower"* ]]; then
                      echo "    âœ… Function name contains directory: $func_name (in $FUNCTION_NAME)"
                      SOURCE_FUNCTION_DIR="$func_dir"
                      break
                    fi
                    
                    # Strategy 6: Directory name contains function name
                    if [[ "$func_name_lower" == *"$FUNCTION_NAME_LOWER"* ]]; then
                      echo "    âœ… Directory contains function name: $FUNCTION_NAME (in $func_name)"
                      SOURCE_FUNCTION_DIR="$func_dir"
                      break
                    fi
                    
                    # Strategy 7: Handle kebab-case to camelCase conversion
                    func_name_camel=$(echo "$func_name" | sed 's/-\([a-z]\)/\U\1/g')
                    func_name_camel_lower=$(echo "$func_name_camel" | tr '[:upper:]' '[:lower:]')
                    
                    if [[ "$LOGICAL_ID_LOWER" == *"$func_name_camel_lower"* ]]; then
                      echo "    âœ… Kebab-to-camel match found: $func_name -> $func_name_camel"
                      SOURCE_FUNCTION_DIR="$func_dir"
                      break
                    fi
                    
                    # Strategy 8: Handle camelCase to kebab-case conversion
                    logical_id_kebab=$(echo "$LOGICAL_ID" | sed 's/\([A-Z]\)/-\L\1/g' | sed 's/^-//')
                    logical_id_kebab_lower=$(echo "$logical_id_kebab" | tr '[:upper:]' '[:lower:]')
                    
                    if [ "$logical_id_kebab_lower" = "$func_name_lower" ]; then
                      echo "    âœ… CamelCase-to-kebab match found: $LOGICAL_ID -> $logical_id_kebab"
                      SOURCE_FUNCTION_DIR="$func_dir"
                      break
                    fi
                  fi
                done
                
                if [ -n "$SOURCE_FUNCTION_DIR" ] && [ -d "$SOURCE_FUNCTION_DIR" ]; then
                  echo "  ðŸ“ Source directory: $SOURCE_FUNCTION_DIR"
                  
                  # Create a temporary zip with the repository code
                  TEMP_ZIP="/tmp/${FUNCTION_NAME}-repo-code.zip"
                  cd "$SOURCE_FUNCTION_DIR"
                  zip -r "$TEMP_ZIP" . -x "*.pyc" "__pycache__/*" "*.git*"
                  cd - >/dev/null
                  
                  echo "  ðŸ“¦ Created deployment package: $TEMP_ZIP"
                  
                  # Force update the Lambda function code
                  echo "  ðŸš€ Updating Lambda function code..."
                  aws lambda update-function-code \
                    --function-name "$FUNCTION_NAME" \
                    --zip-file "fileb://$TEMP_ZIP"
                  
                  echo "  âœ… Function $FUNCTION_NAME code updated successfully"
                  
                  # Clean up
                  rm -f "$TEMP_ZIP"
                else
                  echo "  âš ï¸  Could not map function to source directory, skipping force update"
                fi
              done
            fi
          else
            # Normal deployment for other cases
            # Determine which commit SHA to use for tagging
            COMMIT_FOR_TAGGING="${{ env.DEPLOYMENT_COMMIT_SHA || github.sha }}"
            echo "ðŸ“‹ Using commit for stack tagging: $COMMIT_FOR_TAGGING"
            
            sam deploy \
                 --template-file packaged.yaml \
                 --stack-name ${{ env.STACK_NAME }} \
                 --capabilities CAPABILITY_IAM CAPABILITY_AUTO_EXPAND \
                 --no-fail-on-empty-changeset \
                 --tags GitCommit="$COMMIT_FOR_TAGGING" \
                        GitBranch=${{ github.ref_name }} \
                        GitRepository=${{ github.repository }} \
                        DeploymentTime=$(date -u +"%Y-%m-%dT%H:%M:%SZ") \
                        WorkflowRun=${{ github.run_id }}
          fi
          
          # Determine which commit SHA to use for tagging
          COMMIT_FOR_TAGGING="${{ env.DEPLOYMENT_COMMIT_SHA || github.sha }}"
          
          echo ""
          echo "âœ… Deployment completed successfully"
          echo "ðŸ“‹ Tagged stack with commit: $COMMIT_FOR_TAGGING"
          
          if [ -n "${{ env.DEPLOYMENT_COMMIT_SHA }}" ]; then
            echo "ðŸ“‹ Using new commit SHA from accepted console changes"
            echo "ðŸ“‹ Original workflow commit: ${{ github.sha }}"
            echo "ðŸ“‹ New deployment commit: ${{ env.DEPLOYMENT_COMMIT_SHA }}"
          else
            echo "ðŸ“‹ Using original workflow commit: ${{ github.sha }}"
          fi
          
          echo "ðŸ“‹ Future deployments will use this commit for drift detection"
          
          if [ "${{ github.event.inputs.drift_resolution }}" == "overwrite_console" ]; then
            echo ""
            echo "ðŸ”„ Console changes have been overwritten with repository code"
            echo "âœ… AWS Lambda functions now match the repository source code"
            echo "ðŸ“‹ Drift has been resolved by overwriting console changes"
          fi
