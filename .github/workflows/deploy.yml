name: Deploy SAM Multi-Lambda

on:
  push:
    branches: [ "main" ]
    paths:
      - "src/functions/**"
      - "scripts/generate_template.py"
      - ".github/workflows/deploy.yml"
  workflow_dispatch:
    inputs:
      drift_resolution:
        description: 'How to handle drift if detected'
        required: false
        default: 'prompt'
        type: choice
        options:
        - 'prompt'
        - 'accept_console'
        - 'overwrite_console'
        - 'abort'
      force_deploy:
        description: 'Force deployment bypassing all drift checks'
        required: false
        default: false
        type: boolean

permissions:
  id-token: write   # for OIDC
  contents: write   # for git operations when accepting console changes
  pull-requests: write   # for creating PRs if needed

env:
  AWS_REGION: us-east-1
  ARTIFACT_BUCKET: ayush-lambda-artifacts
  STACK_NAME: my-multi-lambda-stack-actions

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment:
      name: production   # set required reviewers on this environment for approvals

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch full git history for drift detection

      - name: Print OIDC token claims
        run: |
          echo "${ACTIONS_ID_TOKEN_REQUEST_TOKEN}" | cut -d '.' -f1 | base64 -d -i 2>/dev/null || true
          echo "${ACTIONS_ID_TOKEN_REQUEST_TOKEN}" | cut -d '.' -f2 | base64 -d -i 2>/dev/null || true 

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::975049970782:role/GithubActionsRole
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.13"

      - name: Install tooling
        run: |
          pip install --upgrade pip
          pip install aws-sam-cli pyyaml cfn-lint

      - name: Generate template.yaml
        run: python scripts/generate_template.py

      - name: Validate (SAM + cfn-lint)
        run: |
          sam validate --template template.yaml
          cfn-lint template.yaml

      - name: Initial Drift Check
        id: initial-drift
        run: |
          if aws cloudformation describe-stacks --stack-name ${{ env.STACK_NAME }} >/dev/null 2>&1; then
            echo "‚úÖ Stack exists, checking for drift..."
            
            # Start CloudFormation drift detection
            DRIFT_ID=$(aws cloudformation detect-stack-drift \
              --stack-name ${{ env.STACK_NAME }} \
              --query 'StackDriftDetectionId' --output text)
            
            echo "CloudFormation drift detection started with ID: $DRIFT_ID"
            
            # Poll for drift detection completion
            echo "‚è≥ Waiting for CloudFormation drift detection to complete..."
            while true; do
              STATUS=$(aws cloudformation describe-stack-drift-detection-status \
                --stack-drift-detection-id $DRIFT_ID \
                --query 'DetectionStatus' --output text)
              
              if [ "$STATUS" = "DETECTION_COMPLETE" ]; then
                echo "‚úÖ CloudFormation drift detection completed"
                break
              elif [ "$STATUS" = "DETECTION_FAILED" ]; then
                echo "‚ùå CloudFormation drift detection failed"
                exit 1
              else
                echo "‚è≥ CloudFormation drift detection in progress (status: $STATUS)..."
                sleep 5
              fi
            done
            
            # Get CloudFormation drift status
            DRIFT_STATUS=$(aws cloudformation describe-stack-drift-detection-status \
              --stack-drift-detection-id $DRIFT_ID \
              --query 'StackDriftStatus' --output text)
            
            echo "CloudFormation drift status: $DRIFT_STATUS"
            
            if [ "$DRIFT_STATUS" = "DRIFTED" ]; then
              echo "‚ùå CloudFormation stack has drifted! Manual changes detected."
              
              # Get detailed drift information
              echo "üìã CloudFormation Drift Details:"
              aws cloudformation describe-stack-resource-drifts \
                --stack-name ${{ env.STACK_NAME }} \
                --query 'StackResourceDrifts[?StackResourceDriftStatus==`MODIFIED`].[LogicalResourceId,ResourceType,StackResourceDriftStatus]' \
                --output table
              
              echo "Please fix the CloudFormation drift in AWS console before deploying."
              exit 1
            else
              echo "‚úÖ No CloudFormation drift detected"
            fi
            
            # Lambda-specific drift detection (CloudFormation can't detect Lambda code changes)
            echo "üîç Checking Lambda function code drift..."
            echo "‚ÑπÔ∏è  Drift detection compares AWS deployed code with the last deployed commit"
            echo "‚ÑπÔ∏è  This detects manual changes made in AWS console, not legitimate repo updates"
            
            # Get the last deployed commit hash from stack tags
            LAST_DEPLOYED_COMMIT=$(aws cloudformation describe-stacks \
              --stack-name ${{ env.STACK_NAME }} \
              --query 'Stacks[0].Tags[?Key==`GitCommit`].Value' --output text 2>/dev/null || echo "")
            
            if [ -z "$LAST_DEPLOYED_COMMIT" ] || [ "$LAST_DEPLOYED_COMMIT" = "None" ]; then
              echo "‚ö†Ô∏è  No previous deployment commit found in stack tags"
              echo "‚ÑπÔ∏è  This might be the first deployment or an old stack without commit tracking"
              echo "‚ÑπÔ∏è  Skipping Lambda drift detection for this deployment"
              echo "üí° Future deployments will include drift detection"
            else
              echo "üìã Last deployed commit: $LAST_DEPLOYED_COMMIT"
              echo "üìã Current commit: ${{ github.sha }}"
              
              if [ "$LAST_DEPLOYED_COMMIT" = "${{ github.sha }}" ]; then
                echo "‚ÑπÔ∏è  Same commit as last deployment - no drift check needed"
              else
                echo "‚ÑπÔ∏è  Different commit detected - this is a legitimate update, not drift"
                echo "üìã Checking for manual changes made since last deployment..."
                
                # Get all Lambda functions from the stack
                LAMBDA_FUNCTIONS=$(aws cloudformation describe-stack-resources \
                  --stack-name ${{ env.STACK_NAME }} \
                  --query 'StackResources[?ResourceType==`AWS::Lambda::Function`].PhysicalResourceId' \
                  --output text)
                
                if [ -n "$LAMBDA_FUNCTIONS" ]; then
                  LAMBDA_DRIFT_DETECTED=false
                  
                  for FUNCTION_NAME in $LAMBDA_FUNCTIONS; do
                    echo "üìã Checking function: $FUNCTION_NAME"
                    
                    # Find the function's logical ID from the template
                    LOGICAL_ID=$(aws cloudformation describe-stack-resources \
                      --stack-name ${{ env.STACK_NAME }} \
                      --query "StackResources[?PhysicalResourceId=='$FUNCTION_NAME'].LogicalResourceId" --output text)
                    
                    echo "  Function logical ID: $LOGICAL_ID"
                    
                    # Download current function code from AWS
                    echo "  Downloading current function code from AWS..."
                    TEMP_DIR_AWS="/tmp/${FUNCTION_NAME}-aws-code"
                    mkdir -p "$TEMP_DIR_AWS"
                    
                    # Get the function code URL and download it
                    DOWNLOAD_URL=$(aws lambda get-function \
                      --function-name $FUNCTION_NAME \
                      --query 'Code.Location' --output text)
                    
                    if [ "$DOWNLOAD_URL" != "None" ] && [ -n "$DOWNLOAD_URL" ]; then
                      # Download and extract the current AWS code
                      curl -s "$DOWNLOAD_URL" -o "$TEMP_DIR_AWS/current-code.zip"
                      cd "$TEMP_DIR_AWS"
                      unzip -q current-code.zip
                      rm current-code.zip
                      cd - >/dev/null
                      
                      # Get the code from the last deployed commit for comparison
                      echo "  Getting code from last deployed commit: $LAST_DEPLOYED_COMMIT"
                      TEMP_DIR_LAST="/tmp/${FUNCTION_NAME}-last-commit"
                      mkdir -p "$TEMP_DIR_LAST"
                      
                      # Find the source function directory using dynamic mapping
                      SOURCE_FUNCTION_DIR=""
                      # Convert logical ID to lowercase for case-insensitive matching
                      LOGICAL_ID_LOWER=$(echo "$LOGICAL_ID" | tr '[:upper:]' '[:lower:]')
                      
                      echo "  Attempting to map logical ID '$LOGICAL_ID' to source directory..."
                      
                      # Dynamic mapping strategy with multiple approaches
                      for func_dir in src/functions/*/; do
                        if [ -d "$func_dir" ]; then
                          func_name=$(basename "$func_dir")
                          func_name_lower=$(echo "$func_name" | tr '[:upper:]' '[:lower:]')
                          
                          echo "    Checking directory: $func_name"
                          
                          # Strategy 1: Exact match (case-insensitive)
                          if [ "$LOGICAL_ID_LOWER" = "$func_name_lower" ]; then
                            echo "    ‚úÖ Exact match found: $func_name"
                            SOURCE_FUNCTION_DIR="$func_dir"
                            break
                          fi
                          
                          # Strategy 2: Logical ID contains directory name
                          if [[ "$LOGICAL_ID_LOWER" == *"$func_name_lower"* ]]; then
                            echo "    ‚úÖ Substring match found: $func_name (in $LOGICAL_ID)"
                            SOURCE_FUNCTION_DIR="$func_dir"
                            break
                          fi
                          
                          # Strategy 3: Directory name contains logical ID
                          if [[ "$func_name_lower" == *"$LOGICAL_ID_LOWER"* ]]; then
                            echo "    ‚úÖ Reverse substring match found: $LOGICAL_ID (in $func_name)"
                            SOURCE_FUNCTION_DIR="$func_dir"
                            break
                          fi
                          
                          # Strategy 4: Handle kebab-case to camelCase conversion
                          # Convert kebab-case to camelcase for comparison
                          func_name_camel=$(echo "$func_name" | sed 's/-\([a-z]\)/\U\1/g')
                          func_name_camel_lower=$(echo "$func_name_camel" | tr '[:upper:]' '[:lower:]')
                          
                          if [[ "$LOGICAL_ID_LOWER" == *"$func_name_camel_lower"* ]]; then
                            echo "    ‚úÖ Kebab-to-camel match found: $func_name -> $func_name_camel"
                            SOURCE_FUNCTION_DIR="$func_dir"
                            break
                          fi
                        fi
                      done
                      
                      # Check if mapping was successful
                      if [ -n "$SOURCE_FUNCTION_DIR" ] && [ -d "$SOURCE_FUNCTION_DIR" ]; then
                        echo "  Mapped to source directory: $SOURCE_FUNCTION_DIR"
                        
                        # Get the file from the last deployed commit
                        MAIN_FILE=""
                        if [ -f "$SOURCE_FUNCTION_DIR/lambda_function.py" ]; then
                          MAIN_FILE="lambda_function.py"
                        elif [ -f "$SOURCE_FUNCTION_DIR/app.py" ]; then
                          MAIN_FILE="app.py"
                        elif [ -f "$SOURCE_FUNCTION_DIR/index.js" ]; then
                          MAIN_FILE="index.js"
                        fi
                        
                        if [ -n "$MAIN_FILE" ]; then
                          echo "  Comparing main file: $MAIN_FILE"
                          
                          # Get the file content from the last deployed commit
                          # Remove trailing slash from SOURCE_FUNCTION_DIR for proper git path
                          SOURCE_PATH="${SOURCE_FUNCTION_DIR%/}/$MAIN_FILE"
                          echo "  Retrieving file from git: $LAST_DEPLOYED_COMMIT:$SOURCE_PATH"
                          
                          # Verify the commit exists first
                          if ! git cat-file -e "$LAST_DEPLOYED_COMMIT" 2>/dev/null; then
                            echo "  ‚ö†Ô∏è  Commit $LAST_DEPLOYED_COMMIT not found in git history"
                            echo "  ‚ÑπÔ∏è  Skipping drift check for this function"
                            rm -rf "$TEMP_DIR_AWS" "$TEMP_DIR_LAST"
                            continue
                          fi
                          
                          # Get the file content from the last deployed commit
                          if ! git show "$LAST_DEPLOYED_COMMIT:$SOURCE_PATH" > "$TEMP_DIR_LAST/$MAIN_FILE" 2>/dev/null; then
                            echo "  ‚ö†Ô∏è  Could not retrieve file $SOURCE_PATH from commit $LAST_DEPLOYED_COMMIT"
                            echo "  ‚ÑπÔ∏è  File may not have existed in that commit"
                            echo "  ‚ÑπÔ∏è  Skipping drift check for this function"
                            rm -rf "$TEMP_DIR_AWS" "$TEMP_DIR_LAST"
                            continue
                          fi
                          
                          # Calculate checksums - compare AWS deployed code with last deployed commit
                          LAST_COMMIT_CHECKSUM=$(sha256sum "$TEMP_DIR_LAST/$MAIN_FILE" | cut -d' ' -f1)
                          AWS_CHECKSUM=$(sha256sum "$TEMP_DIR_AWS/$MAIN_FILE" 2>/dev/null | cut -d' ' -f1 || echo "missing")
                          
                          echo "  Last deployed commit checksum: $LAST_COMMIT_CHECKSUM"
                          echo "  AWS deployed checksum: $AWS_CHECKSUM"
                          
                          if [ "$LAST_COMMIT_CHECKSUM" != "$AWS_CHECKSUM" ]; then
                            echo "  ‚ùå Lambda function $FUNCTION_NAME has code drift!"
                            echo "  üìã AWS deployed code differs from last deployed commit"
                            echo "  üîß Someone manually modified the function code in AWS console"
                            
                            # Show the differences if possible
                            if [ "$AWS_CHECKSUM" != "missing" ]; then
                              echo "  üìã Code differences detected:"
                              diff -u "$TEMP_DIR_LAST/$MAIN_FILE" "$TEMP_DIR_AWS/$MAIN_FILE" || true
                            else
                              echo "  üìã Main file missing in AWS deployment"
                            fi
                            
                            LAMBDA_DRIFT_DETECTED=true
                          else
                            echo "  ‚úÖ Lambda function $FUNCTION_NAME matches last deployed commit"
                          fi
                        else
                          echo "  ‚ö†Ô∏è  Could not find main Lambda file in source directory"
                          echo "  ‚ÑπÔ∏è  Skipping drift check for this function"
                        fi
                      else
                        echo "  ‚ö†Ô∏è  Could not map function to source directory"
                        echo "  ‚ÑπÔ∏è  Available directories: $(ls -d src/functions/*/ 2>/dev/null | tr '\n' ' ')"
                        echo "  ‚ÑπÔ∏è  Skipping drift check for this function"
                      fi
                      
                      # Clean up temporary directories
                      rm -rf "$TEMP_DIR_AWS" "$TEMP_DIR_LAST"
                    else
                      echo "  ‚ö†Ô∏è  Could not get download URL for function code"
                      echo "  ‚ÑπÔ∏è  Skipping drift check for this function"
                    fi
                  done
                  
                  if [ "$LAMBDA_DRIFT_DETECTED" = true ]; then
                    echo ""
                    echo "‚ùå Lambda code drift detected!"
                    echo "üîß Someone manually modified Lambda function code in the AWS console"
                    echo "üí° This type of drift cannot be detected by CloudFormation drift detection"
                    echo ""
                    echo "drift_detected=true" >> $GITHUB_OUTPUT
                    echo "drift_summary=Lambda code drift detected - manual console changes found" >> $GITHUB_OUTPUT
                  else
                    echo "‚úÖ No Lambda code drift detected"
                    echo "drift_detected=false" >> $GITHUB_OUTPUT
                  fi
                else
                  echo "‚ÑπÔ∏è  No Lambda functions found in stack"
                  echo "drift_detected=false" >> $GITHUB_OUTPUT
                fi
              fi
            fi
            
            # Ensure drift_detected is set for cases where no Lambda drift check was performed
            if ! grep -q "drift_detected=" $GITHUB_OUTPUT 2>/dev/null; then
              echo "drift_detected=false" >> $GITHUB_OUTPUT
            fi
            
            echo "‚úÖ All drift checks passed, proceeding with deployment"
            echo "stack_exists=true" >> $GITHUB_OUTPUT
          else
            echo "üì¶ Stack doesn't exist yet - this will be a first deployment"
            echo "‚úÖ Will create stack and then check for drift"
            echo "stack_exists=false" >> $GITHUB_OUTPUT
            echo "drift_detected=false" >> $GITHUB_OUTPUT
          fi

      - name: Build (use Lambda-like container for deps)
        run: sam build --use-container

      - name: Package
        run: |
          sam package \
               --template-file .aws-sam/build/template.yaml \
               --s3-bucket ${{ env.ARTIFACT_BUCKET }} \
               --output-template-file packaged.yaml

      - name: Create Stack Infrastructure (First Deployment)
        if: steps.initial-drift.outputs.stack_exists == 'false'
        run: |
          echo "üöÄ Creating new stack infrastructure..."
          
          # Create changeset without executing it
          sam deploy \
               --template-file packaged.yaml \
               --stack-name ${{ env.STACK_NAME }} \
               --capabilities CAPABILITY_IAM CAPABILITY_AUTO_EXPAND \
               --no-execute-changeset
          
          # Execute the changeset to create stack
          CHANGESET_NAME=$(aws cloudformation list-change-sets \
            --stack-name ${{ env.STACK_NAME }} \
            --query 'Summaries[0].ChangeSetName' --output text)
          
          echo "Executing changeset: $CHANGESET_NAME"
          aws cloudformation execute-change-set \
            --change-set-name $CHANGESET_NAME \
            --stack-name ${{ env.STACK_NAME }}
          
          # Wait for stack creation to complete
          echo "‚è≥ Waiting for stack creation to complete..."
          aws cloudformation wait stack-create-complete \
            --stack-name ${{ env.STACK_NAME }}
          
          echo "‚úÖ Stack infrastructure created successfully"

      - name: Post-Creation Drift Check (New Stacks Only)
        if: steps.initial-drift.outputs.stack_exists == 'false'
        run: |
          echo "üîç Running drift check after stack creation (before deployment)..."
          
          # Wait a moment for stack to stabilize
          sleep 10
          
          # Start drift detection
          DRIFT_ID=$(aws cloudformation detect-stack-drift \
            --stack-name ${{ env.STACK_NAME }} \
            --query 'StackDriftDetectionId' --output text)
          
          echo "Drift detection started with ID: $DRIFT_ID"
          
          # Poll for drift detection completion
          echo "‚è≥ Waiting for drift detection to complete..."
          while true; do
            STATUS=$(aws cloudformation describe-stack-drift-detection-status \
              --stack-drift-detection-id $DRIFT_ID \
              --query 'DetectionStatus' --output text)
            
            if [ "$STATUS" = "DETECTION_COMPLETE" ]; then
              echo "‚úÖ Drift detection completed"
              break
            elif [ "$STATUS" = "DETECTION_FAILED" ]; then
              echo "‚ùå Drift detection failed"
              exit 1
            else
              echo "‚è≥ Drift detection in progress (status: $STATUS)..."
              sleep 5
            fi
          done
          
          # Get drift status
          DRIFT_STATUS=$(aws cloudformation describe-stack-drift-detection-status \
            --stack-drift-detection-id $DRIFT_ID \
            --query 'StackDriftStatus' --output text)
          
          echo "Post-creation drift status: $DRIFT_STATUS"
          
          if [ "$DRIFT_STATUS" = "DRIFTED" ]; then
            echo "‚ùå Stack has drifted after creation! Manual changes detected."
            
            # Get detailed drift information
            echo "üìã Drift Details:"
            aws cloudformation describe-stack-resource-drifts \
              --stack-name ${{ env.STACK_NAME }} \
              --query 'StackResourceDrifts[?StackResourceDriftStatus==`MODIFIED`].[LogicalResourceId,ResourceType,StackResourceDriftStatus]' \
              --output table
            
            echo "‚ö†Ô∏è  Someone made manual changes to the stack after creation!"
            echo "‚ùå Deployment blocked - fix drift before proceeding"
            exit 1
          else
            echo "‚úÖ No drift detected after stack creation"
            echo "‚úÖ Proceeding with code deployment..."
          fi

      - name: Handle Drift Detection
        if: steps.initial-drift.outputs.drift_detected == 'true' && github.event.inputs.force_deploy != 'true' && github.event.inputs.drift_resolution != 'accept_console' && github.event.inputs.drift_resolution != 'overwrite_console' && github.event.inputs.drift_resolution != 'abort'
        run: |
          echo "üö® DRIFT DETECTED - MANUAL APPROVAL REQUIRED"
          echo ""
          echo "üìã Drift Summary: ${{ steps.initial-drift.outputs.drift_summary }}"
          echo ""
          echo "üîß Resolution Options:"
          echo "  1. Accept Console Changes - Pull console changes into repository"
          echo "  2. Overwrite Console Changes - Deploy repository code (discards console changes)"
          echo "  3. Abort - Stop deployment for manual investigation"
          echo ""
          echo "‚ö†Ô∏è  Current Resolution Setting: ${{ github.event.inputs.drift_resolution || 'prompt (default)' }}"
          echo "‚ö†Ô∏è  Trigger Type: ${{ github.event_name }}"
          echo ""
          echo "üõë Workflow paused for manual approval"
          echo "üë§ Please review the drift details above and re-run this workflow with your chosen resolution:"
          echo "   - drift_resolution: accept_console (to accept console changes)"
          echo "   - drift_resolution: overwrite_console (to overwrite with repo code)"
          echo "   - drift_resolution: abort (to stop deployment)"
          echo ""
          echo "üí° You can also set force_deploy: true to bypass all drift checks"
          exit 1

      - name: Accept Console Changes
        if: steps.initial-drift.outputs.drift_detected == 'true' && github.event.inputs.drift_resolution == 'accept_console'
        run: |
          echo "‚úÖ Accepting console changes and syncing with repository..."
          echo ""
          echo "üîÑ This will:"
          echo "  1. Download current AWS Lambda code"
          echo "  2. Update repository files with console changes"
          echo "  3. Create a commit with the console changes"
          echo "  4. Continue with deployment using the updated code"
          echo ""
          
          # Get all Lambda functions from the stack
          LAMBDA_FUNCTIONS=$(aws cloudformation describe-stack-resources \
            --stack-name ${{ env.STACK_NAME }} \
            --query 'StackResources[?ResourceType==`AWS::Lambda::Function`].PhysicalResourceId' \
            --output text)
          
          if [ -n "$LAMBDA_FUNCTIONS" ]; then
            for FUNCTION_NAME in $LAMBDA_FUNCTIONS; do
              echo "üì• Processing function: $FUNCTION_NAME"
              
              # Find the function's logical ID and map to source directory
              LOGICAL_ID=$(aws cloudformation describe-stack-resources \
                --stack-name ${{ env.STACK_NAME }} \
                --query "StackResources[?PhysicalResourceId=='$FUNCTION_NAME'].LogicalResourceId" --output text)
              
              # Download current function code
              TEMP_DIR="/tmp/${FUNCTION_NAME}-console-code"
              mkdir -p "$TEMP_DIR"
              
              DOWNLOAD_URL=$(aws lambda get-function \
                --function-name $FUNCTION_NAME \
                --query 'Code.Location' --output text)
              
              if [ "$DOWNLOAD_URL" != "None" ] && [ -n "$DOWNLOAD_URL" ]; then
                curl -s "$DOWNLOAD_URL" -o "$TEMP_DIR/console-code.zip"
                cd "$TEMP_DIR"
                unzip -q console-code.zip
                rm console-code.zip
                cd - >/dev/null
                
                # Map to source directory (reuse mapping logic)
                SOURCE_FUNCTION_DIR=""
                LOGICAL_ID_LOWER=$(echo "$LOGICAL_ID" | tr '[:upper:]' '[:lower:]')
                
                for func_dir in src/functions/*/; do
                  if [ -d "$func_dir" ]; then
                    func_name=$(basename "$func_dir")
                    func_name_lower=$(echo "$func_name" | tr '[:upper:]' '[:lower:]')
                    
                    if [ "$LOGICAL_ID_LOWER" = "$func_name_lower" ] || \
                       [[ "$LOGICAL_ID_LOWER" == *"$func_name_lower"* ]] || \
                       [[ "$func_name_lower" == *"$LOGICAL_ID_LOWER"* ]]; then
                      SOURCE_FUNCTION_DIR="$func_dir"
                      break
                    fi
                  fi
                done
                
                if [ -n "$SOURCE_FUNCTION_DIR" ] && [ -d "$SOURCE_FUNCTION_DIR" ]; then
                  echo "  üìÅ Updating source directory: $SOURCE_FUNCTION_DIR"
                  
                  # Find main file and update it
                  MAIN_FILE=""
                  if [ -f "$SOURCE_FUNCTION_DIR/lambda_function.py" ]; then
                    MAIN_FILE="lambda_function.py"
                  elif [ -f "$SOURCE_FUNCTION_DIR/app.py" ]; then
                    MAIN_FILE="app.py"
                  elif [ -f "$SOURCE_FUNCTION_DIR/index.js" ]; then
                    MAIN_FILE="index.js"
                  fi
                  
                  if [ -n "$MAIN_FILE" ] && [ -f "$TEMP_DIR/$MAIN_FILE" ]; then
                    echo "  üìù Updating $MAIN_FILE with console changes"
                    cp "$TEMP_DIR/$MAIN_FILE" "$SOURCE_FUNCTION_DIR/$MAIN_FILE"
                  fi
                fi
                
                rm -rf "$TEMP_DIR"
              fi
            done
            
            # Configure git for the commit
            git config user.name "GitHub Actions"
            git config user.email "actions@github.com"
            
            # Add and commit the changes
            git add src/functions/
            if git diff --staged --quiet; then
              echo "‚ÑπÔ∏è  No changes to commit"
            else
              git commit -m "Accept console changes from AWS Lambda functions

              This commit incorporates manual changes that were made directly in the AWS console.
              
              Workflow: ${{ github.workflow }}
              Run ID: ${{ github.run_id }}
              Original commit: ${{ github.sha }}"
              
              echo "‚úÖ Console changes committed to repository"
            fi
          fi

      - name: Overwrite Console Changes
        if: steps.initial-drift.outputs.drift_detected == 'true' && github.event.inputs.drift_resolution == 'overwrite_console'
        run: |
          echo "üîÑ Overwriting console changes with repository code..."
          echo ""
          echo "üìã Drift Summary: ${{ steps.initial-drift.outputs.drift_summary }}"
          echo ""
          echo "‚ö†Ô∏è  This will:"
          echo "  1. Deploy repository code to AWS Lambda functions"
          echo "  2. Overwrite any manual changes made in AWS console"
          echo "  3. Update commit tag to establish new baseline"
          echo "  4. Console changes will be permanently lost"
          echo ""
          echo "‚úÖ Proceeding with deployment - console changes will be overwritten"
          echo "üìã Repository code will be deployed as the authoritative source"
          echo ""
          echo "üîß Debug Info:"
          echo "  - drift_detected: ${{ steps.initial-drift.outputs.drift_detected }}"
          echo "  - drift_resolution: ${{ github.event.inputs.drift_resolution }}"
          echo "  - force_deploy: ${{ github.event.inputs.force_deploy }}"
          echo "  - Next step (Deploy Code) should run with overwrite_console logic"

      - name: Abort on Drift
        if: steps.initial-drift.outputs.drift_detected == 'true' && github.event.inputs.drift_resolution == 'abort'
        run: |
          echo "üõë Deployment aborted due to drift detection"
          echo ""
          echo "üìã Drift Summary: ${{ steps.initial-drift.outputs.drift_summary }}"
          echo ""
          echo "üîß Manual Action Required:"
          echo "  1. Review the drift details in the logs above"
          echo "  2. Decide whether to accept console changes or revert them"
          echo "  3. Re-run the workflow with appropriate drift_resolution setting"
          echo ""
          echo "üí° Resolution options:"
          echo "  - accept_console: Accept and commit console changes"
          echo "  - overwrite_console: Deploy repository code (discards console changes)"
          echo "  - force_deploy: Bypass all drift checks"
          exit 1

      - name: Deploy Code (Final Step)
        if: github.event.inputs.force_deploy == 'true' || steps.initial-drift.outputs.drift_detected != 'true' || (steps.initial-drift.outputs.drift_detected == 'true' && (github.event.inputs.drift_resolution == 'accept_console' || github.event.inputs.drift_resolution == 'overwrite_console'))
        run: |
          echo "üîß Deploy Code Step - Debug Info:"
          echo "  - force_deploy: ${{ github.event.inputs.force_deploy }}"
          echo "  - drift_detected: ${{ steps.initial-drift.outputs.drift_detected }}"
          echo "  - drift_resolution: ${{ github.event.inputs.drift_resolution }}"
          echo "  - stack_exists: ${{ steps.initial-drift.outputs.stack_exists }}"
          echo ""
          
          if [ "${{ github.event.inputs.force_deploy }}" == "true" ]; then
            echo "üöÄ Force deployment - bypassing all drift checks"
          elif [ "${{ steps.initial-drift.outputs.drift_detected }}" == "true" ]; then
            if [ "${{ github.event.inputs.drift_resolution }}" == "accept_console" ]; then
              echo "‚úÖ Deploying with accepted console changes"
            elif [ "${{ github.event.inputs.drift_resolution }}" == "overwrite_console" ]; then
              echo "üîÑ Deploying repository code - overwriting console changes"
              echo "‚ö†Ô∏è  This deployment will replace AWS Lambda code with repository code"
              echo "‚ö†Ô∏è  Any manual console changes will be permanently lost"
            fi
          elif [ "${{ steps.initial-drift.outputs.stack_exists }}" == "true" ]; then
            echo "üîÑ Updating existing stack with new code..."
          else
            echo "üì¶ Deploying code to newly created stack..."
          fi
          
          echo ""
          echo "üöÄ Starting SAM deployment..."
          echo "üìã Template: packaged.yaml"
          echo "üìã Stack: ${{ env.STACK_NAME }}"
          echo ""
          
          sam deploy \
               --template-file packaged.yaml \
               --stack-name ${{ env.STACK_NAME }} \
               --capabilities CAPABILITY_IAM CAPABILITY_AUTO_EXPAND \
               --no-fail-on-empty-changeset \
               --tags GitCommit=${{ github.sha }} \
                      GitBranch=${{ github.ref_name }} \
                      GitRepository=${{ github.repository }} \
                      DeploymentTime=$(date -u +"%Y-%m-%dT%H:%M:%SZ") \
                      WorkflowRun=${{ github.run_id }}
          
          echo ""
          echo "‚úÖ Deployment completed successfully"
          echo "üìã Tagged stack with commit: ${{ github.sha }}"
          echo "üìã Future deployments will use this commit for drift detection"
          
          if [ "${{ github.event.inputs.drift_resolution }}" == "overwrite_console" ]; then
            echo ""
            echo "üîÑ Console changes have been overwritten with repository code"
            echo "‚úÖ AWS Lambda functions now match the repository source code"
            echo "üìã Drift has been resolved by overwriting console changes"
          fi
