name: Deploy SAM Multi-Lambda

on:
  push:
    branches: [ "main" ]
    paths:
      - "src/functions/**"
      - "scripts/generate_template.py"
      - ".github/workflows/deploy.yml"

permissions:
  id-token: write   # for OIDC
  contents: read

env:
  AWS_REGION: us-east-1
  ARTIFACT_BUCKET: ayush-lambda-artifacts
  STACK_NAME: my-multi-lambda-stack-actions

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment:
      name: production   # set required reviewers on this environment for approvals

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Print OIDC token claims
        run: |
          echo "${ACTIONS_ID_TOKEN_REQUEST_TOKEN}" | cut -d '.' -f1 | base64 -d -i 2>/dev/null || true
          echo "${ACTIONS_ID_TOKEN_REQUEST_TOKEN}" | cut -d '.' -f2 | base64 -d -i 2>/dev/null || true 

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::975049970782:role/GithubActionsRole
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.13"

      - name: Install tooling
        run: |
          pip install --upgrade pip
          pip install aws-sam-cli pyyaml cfn-lint

      - name: Generate template.yaml
        run: python scripts/generate_template.py

      - name: Validate (SAM + cfn-lint)
        run: |
          sam validate --template template.yaml
          cfn-lint template.yaml

      - name: Initial Drift Check
        id: initial-drift
        run: |
          if aws cloudformation describe-stacks --stack-name ${{ env.STACK_NAME }} >/dev/null 2>&1; then
            echo "‚úÖ Stack exists, checking for drift..."
            
            # Start CloudFormation drift detection
            DRIFT_ID=$(aws cloudformation detect-stack-drift \
              --stack-name ${{ env.STACK_NAME }} \
              --query 'StackDriftDetectionId' --output text)
            
            echo "CloudFormation drift detection started with ID: $DRIFT_ID"
            
            # Poll for drift detection completion
            echo "‚è≥ Waiting for CloudFormation drift detection to complete..."
            while true; do
              STATUS=$(aws cloudformation describe-stack-drift-detection-status \
                --stack-drift-detection-id $DRIFT_ID \
                --query 'DetectionStatus' --output text)
              
              if [ "$STATUS" = "DETECTION_COMPLETE" ]; then
                echo "‚úÖ CloudFormation drift detection completed"
                break
              elif [ "$STATUS" = "DETECTION_FAILED" ]; then
                echo "‚ùå CloudFormation drift detection failed"
                exit 1
              else
                echo "‚è≥ CloudFormation drift detection in progress (status: $STATUS)..."
                sleep 5
              fi
            done
            
            # Get CloudFormation drift status
            DRIFT_STATUS=$(aws cloudformation describe-stack-drift-detection-status \
              --stack-drift-detection-id $DRIFT_ID \
              --query 'StackDriftStatus' --output text)
            
            echo "CloudFormation drift status: $DRIFT_STATUS"
            
            if [ "$DRIFT_STATUS" = "DRIFTED" ]; then
              echo "‚ùå CloudFormation stack has drifted! Manual changes detected."
              
              # Get detailed drift information
              echo "üìã CloudFormation Drift Details:"
              aws cloudformation describe-stack-resource-drifts \
                --stack-name ${{ env.STACK_NAME }} \
                --query 'StackResourceDrifts[?StackResourceDriftStatus==`MODIFIED`].[LogicalResourceId,ResourceType,StackResourceDriftStatus]' \
                --output table
              
              echo "Please fix the CloudFormation drift in AWS console before deploying."
              exit 1
            else
              echo "‚úÖ No CloudFormation drift detected"
            fi
            
            # Lambda-specific drift detection (CloudFormation can't detect Lambda code changes)
            echo "üîç Checking Lambda function code drift..."
            echo "‚ÑπÔ∏è  Drift detection compares AWS deployed code with the last deployed commit"
            echo "‚ÑπÔ∏è  This detects manual changes made in AWS console, not legitimate repo updates"
            
            # Get the last deployed commit hash from stack tags
            LAST_DEPLOYED_COMMIT=$(aws cloudformation describe-stacks \
              --stack-name ${{ env.STACK_NAME }} \
              --query 'Stacks[0].Tags[?Key==`GitCommit`].Value' --output text 2>/dev/null || echo "")
            
            if [ -z "$LAST_DEPLOYED_COMMIT" ] || [ "$LAST_DEPLOYED_COMMIT" = "None" ]; then
              echo "‚ö†Ô∏è  No previous deployment commit found in stack tags"
              echo "‚ÑπÔ∏è  This might be the first deployment or an old stack without commit tracking"
              echo "‚ÑπÔ∏è  Skipping Lambda drift detection for this deployment"
              echo "üí° Future deployments will include drift detection"
            else
              echo "üìã Last deployed commit: $LAST_DEPLOYED_COMMIT"
              echo "üìã Current commit: ${{ github.sha }}"
              
              if [ "$LAST_DEPLOYED_COMMIT" = "${{ github.sha }}" ]; then
                echo "‚ÑπÔ∏è  Same commit as last deployment - no drift check needed"
              else
                # Get all Lambda functions from the stack
                LAMBDA_FUNCTIONS=$(aws cloudformation describe-stack-resources \
                  --stack-name ${{ env.STACK_NAME }} \
                  --query 'StackResources[?ResourceType==`AWS::Lambda::Function`].PhysicalResourceId' \
                  --output text)
                
                if [ -n "$LAMBDA_FUNCTIONS" ]; then
                  LAMBDA_DRIFT_DETECTED=false
                  
                  for FUNCTION_NAME in $LAMBDA_FUNCTIONS; do
                    echo "üìã Checking function: $FUNCTION_NAME"
                    
                    # Find the function's logical ID from the template
                    LOGICAL_ID=$(aws cloudformation describe-stack-resources \
                      --stack-name ${{ env.STACK_NAME }} \
                      --query "StackResources[?PhysicalResourceId=='$FUNCTION_NAME'].LogicalResourceId" --output text)
                    
                    echo "  Function logical ID: $LOGICAL_ID"
                    
                    # Download current function code from AWS
                    echo "  Downloading current function code from AWS..."
                    TEMP_DIR="/tmp/${FUNCTION_NAME}-aws-code"
                    mkdir -p "$TEMP_DIR"
                    
                    # Get the function code URL and download it
                    DOWNLOAD_URL=$(aws lambda get-function \
                      --function-name $FUNCTION_NAME \
                      --query 'Code.Location' --output text)
                    
                    if [ "$DOWNLOAD_URL" != "None" ] && [ -n "$DOWNLOAD_URL" ]; then
                      # Download and extract the current code
                      curl -s "$DOWNLOAD_URL" -o "$TEMP_DIR/current-code.zip"
                      cd "$TEMP_DIR"
                      unzip -q current-code.zip
                      rm current-code.zip
                      cd - >/dev/null
                      
                      # Find the source function directory using dynamic mapping
                      SOURCE_FUNCTION_DIR=""
                      # Convert logical ID to lowercase for case-insensitive matching
                      LOGICAL_ID_LOWER=$(echo "$LOGICAL_ID" | tr '[:upper:]' '[:lower:]')
                      
                      echo "  Attempting to map logical ID '$LOGICAL_ID' to source directory..."
                      
                      # Dynamic mapping strategy with multiple approaches
                      for func_dir in src/functions/*/; do
                        if [ -d "$func_dir" ]; then
                          func_name=$(basename "$func_dir")
                          func_name_lower=$(echo "$func_name" | tr '[:upper:]' '[:lower:]')
                          
                          echo "    Checking directory: $func_name"
                          
                          # Strategy 1: Exact match (case-insensitive)
                          if [ "$LOGICAL_ID_LOWER" = "$func_name_lower" ]; then
                            echo "    ‚úÖ Exact match found: $func_name"
                            SOURCE_FUNCTION_DIR="$func_dir"
                            break
                          fi
                          
                          # Strategy 2: Logical ID contains directory name
                          if [[ "$LOGICAL_ID_LOWER" == *"$func_name_lower"* ]]; then
                            echo "    ‚úÖ Substring match found: $func_name (in $LOGICAL_ID)"
                            SOURCE_FUNCTION_DIR="$func_dir"
                            break
                          fi
                          
                          # Strategy 3: Directory name contains logical ID
                          if [[ "$func_name_lower" == *"$LOGICAL_ID_LOWER"* ]]; then
                            echo "    ‚úÖ Reverse substring match found: $LOGICAL_ID (in $func_name)"
                            SOURCE_FUNCTION_DIR="$func_dir"
                            break
                          fi
                          
                          # Strategy 4: Handle kebab-case to camelCase conversion
                          # Convert kebab-case to camelcase for comparison
                          func_name_camel=$(echo "$func_name" | sed 's/-\([a-z]\)/\U\1/g')
                          func_name_camel_lower=$(echo "$func_name_camel" | tr '[:upper:]' '[:lower:]')
                          
                          if [[ "$LOGICAL_ID_LOWER" == *"$func_name_camel_lower"* ]]; then
                            echo "    ‚úÖ Kebab-to-camel match found: $func_name -> $func_name_camel"
                            SOURCE_FUNCTION_DIR="$func_dir"
                            break
                          fi
            
            echo "‚úÖ All drift checks passed, proceeding with deployment"
            echo "stack_exists=true" >> $GITHUB_OUTPUT
          else
            echo "üì¶ Stack doesn't exist yet - this will be a first deployment"
            echo "‚úÖ Will create stack and then check for drift"
            echo "stack_exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Build (use Lambda-like container for deps)
        run: sam build --use-container

      - name: Package
        run: |
          sam package \
               --template-file .aws-sam/build/template.yaml \
               --s3-bucket ${{ env.ARTIFACT_BUCKET }} \
               --output-template-file packaged.yaml

      - name: Create Stack Infrastructure (First Deployment)
        if: steps.initial-drift.outputs.stack_exists == 'false'
        run: |
          echo "üöÄ Creating new stack infrastructure..."
          
          # Create changeset without executing it
          sam deploy \
               --template-file packaged.yaml \
               --stack-name ${{ env.STACK_NAME }} \
               --capabilities CAPABILITY_IAM CAPABILITY_AUTO_EXPAND \
               --no-execute-changeset
          
          # Execute the changeset to create stack
          CHANGESET_NAME=$(aws cloudformation list-change-sets \
            --stack-name ${{ env.STACK_NAME }} \
            --query 'Summaries[0].ChangeSetName' --output text)
          
          echo "Executing changeset: $CHANGESET_NAME"
          aws cloudformation execute-change-set \
            --change-set-name $CHANGESET_NAME \
            --stack-name ${{ env.STACK_NAME }}
          
          # Wait for stack creation to complete
          echo "‚è≥ Waiting for stack creation to complete..."
          aws cloudformation wait stack-create-complete \
            --stack-name ${{ env.STACK_NAME }}
          
          echo "‚úÖ Stack infrastructure created successfully"

      - name: Post-Creation Drift Check (New Stacks Only)
        if: steps.initial-drift.outputs.stack_exists == 'false'
        run: |
          echo "ÔøΩ Running drift check after stack creation (before deployment)..."
          
          # Wait a moment for stack to stabilize
          sleep 10
          
          # Start drift detection
          DRIFT_ID=$(aws cloudformation detect-stack-drift \
            --stack-name ${{ env.STACK_NAME }} \
            --query 'StackDriftDetectionId' --output text)
          
          echo "Drift detection started with ID: $DRIFT_ID"
          
          # Poll for drift detection completion
          echo "‚è≥ Waiting for drift detection to complete..."
          while true; do
            STATUS=$(aws cloudformation describe-stack-drift-detection-status \
              --stack-drift-detection-id $DRIFT_ID \
              --query 'DetectionStatus' --output text)
            
            if [ "$STATUS" = "DETECTION_COMPLETE" ]; then
              echo "‚úÖ Drift detection completed"
              break
            elif [ "$STATUS" = "DETECTION_FAILED" ]; then
              echo "‚ùå Drift detection failed"
              exit 1
            else
              echo "‚è≥ Drift detection in progress (status: $STATUS)..."
              sleep 5
            fi
          done
          
          # Get drift status
          DRIFT_STATUS=$(aws cloudformation describe-stack-drift-detection-status \
            --stack-drift-detection-id $DRIFT_ID \
            --query 'StackDriftStatus' --output text)
          
          echo "Post-creation drift status: $DRIFT_STATUS"
          
          if [ "$DRIFT_STATUS" = "DRIFTED" ]; then
            echo "‚ùå Stack has drifted after creation! Manual changes detected."
            
            # Get detailed drift information
            echo "üìã Drift Details:"
            aws cloudformation describe-stack-resource-drifts \
              --stack-name ${{ env.STACK_NAME }} \
              --query 'StackResourceDrifts[?StackResourceDriftStatus==`MODIFIED`].[LogicalResourceId,ResourceType,StackResourceDriftStatus]' \
              --output table
            
            echo "‚ö†Ô∏è  Someone made manual changes to the stack after creation!"
            echo "‚ùå Deployment blocked - fix drift before proceeding"
            exit 1
          else
            echo "‚úÖ No drift detected after stack creation"
            echo "‚úÖ Proceeding with code deployment..."
          fi

      - name: Deploy Code (Final Step)
        run: |
          if [ "${{ steps.initial-drift.outputs.stack_exists }}" == "true" ]; then
            echo "ÔøΩ Updating existing stack with new code..."
          else
            echo "üì¶ Deploying code to newly created stack..."
          fi
          
          sam deploy \
               --template-file packaged.yaml \
               --stack-name ${{ env.STACK_NAME }} \
               --capabilities CAPABILITY_IAM CAPABILITY_AUTO_EXPAND \
               --no-fail-on-empty-changeset
          
          echo "‚úÖ Deployment completed successfully"
